/**
 * ComponentDocumentationGenerator.ts
 * 
 * Utility for generating and maintaining documentation for React components.
 * This tool helps ensure components are well-documented and relationships are clear.
 */

import { ComponentMetadata, getAllComponents, findComponentByName } from './ComponentRegistry';
import { generateComponentDocTemplate } from './ComponentAnalyzer';

/**
 * Generate a Component README for a shared components folder
 */
export const generateComponentReadme = (): string => {
  const components = getAllComponents();
  
  const categorizedComponents: Record<string, ComponentMetadata[]> = {};
  
  components.forEach(component => {
    if (!categorizedComponents[component.category]) {
      categorizedComponents[component.category] = [];
    }
    categorizedComponents[component.category].push(component);
  });
  
  let readmeContent = `# Component Documentation\n\n`;
  readmeContent += `This document provides an overview of all components in the application, their purpose, and their relationships.\n\n`;
  
  Object.entries(categorizedComponents).forEach(([category, comps]) => {
    readmeContent += `## ${category.charAt(0).toUpperCase() + category.slice(1)} Components\n\n`;
    
    comps.forEach(comp => {
      readmeContent += `### ${comp.name}\n\n`;
      readmeContent += `${comp.description}\n\n`;
      readmeContent += `- **Path:** \`${comp.path}\`\n`;
      
      if (comp.dependencies.length > 0) {
        readmeContent += `- **Dependencies:** ${comp.dependencies.join(', ')}\n`;
      } else {
        readmeContent += `- **Dependencies:** None\n`;
      }
      
      if (comp.usedBy.length > 0) {
        readmeContent += `- **Used by:** ${comp.usedBy.join(', ')}\n`;
      } else {
        readmeContent += `- **Used by:** None\n`;
      }
      
      if (comp.propsInterface) {
        readmeContent += `- **Props Interface:** \`${comp.propsInterface}\`\n`;
      }
      
      if (comp.example) {
        readmeContent += `\n**Example Usage:**\n\n\`\`\`tsx\n${comp.example}\n\`\`\`\n`;
      }
      
      readmeContent += `\n`;
    });
  });
  
  return readmeContent;
};

/**
 * Generate a component index file that exports all components in a category
 */
export const generateComponentIndex = (category: string): string => {
  const components = getAllComponents().filter(comp => comp.category === category);
  
  let indexContent = `/**
 * Index file for ${category} components
 * This file is automatically generated - DO NOT EDIT MANUALLY
 */\n\n`;
  
  // Add imports
  components.forEach(comp => {
    // Extract the relative path within the category
    // For example, if the path is "components/Layout/Header.tsx", we want "./Header"
    const pathParts = comp.path.split('/');
    const fileName = pathParts[pathParts.length - 1].replace(/\.tsx?$/, '');
    indexContent += `import ${comp.name} from './${fileName}';\n`;
  });
  
  indexContent += `\nexport {\n`;
  components.forEach(comp => {
    indexContent += `  ${comp.name},\n`;
  });
  indexContent += `};\n`;
  
  return indexContent;
};

/**
 * Generate a component template with proper documentation
 */
export const generateComponentTemplate = (name: string, description: string, category: string): string => {
  const template = `import React from 'react';

/**
 * ${name}
 * 
 * ${description}
 * 
 * @category ${category}
 */

export interface ${name}Props {
  // Define props here
}

const ${name}: React.FC<${name}Props> = (props) => {
  return (
    <div>
      {/* Component implementation */}
    </div>
  );
};

export default ${name};
`;

  return template;
};

/**
 * Update a component file with proper documentation
 * This function would be used to add JSDoc comments to existing components
 */
export const updateComponentDocumentation = (componentName: string): string => {
  const component = findComponentByName(componentName);
  if (!component) {
    return `Component "${componentName}" not found in registry`;
  }
  
  const docTemplate = generateComponentDocTemplate(componentName);
  return `Component "${componentName}" documentation template generated:\n\n${docTemplate}`;
};

/**
 * Generate a component dependency graph in Mermaid format
 * This can be rendered in Markdown documents that support Mermaid
 */
export const generateComponentDependencyGraph = (): string => {
  const components = getAllComponents();
  
  let mermaidGraph = `graph TD\n`;
  
  // Add nodes
  components.forEach(comp => {
    mermaidGraph += `  ${comp.name}["${comp.name}"]\n`;
  });
  
  // Add relationships
  components.forEach(comp => {
    comp.dependencies.forEach(dep => {
      mermaidGraph += `  ${comp.name} --> ${dep}\n`;
    });
  });
  
  return mermaidGraph;
};

/**
 * Generate a component usage guide for developers
 */
export const generateComponentUsageGuide = (): string => {
  let guide = `# Component Usage Guide\n\n`;
  guide += `This guide provides best practices for working with components in our application.\n\n`;
  
  guide += `## Component Categories\n\n`;
  guide += `Components are organized into the following categories:\n\n`;
  guide += `- **Layout:** Components that structure the application layout\n`;
  guide += `- **UI:** Reusable UI elements like buttons, cards, etc.\n`;
  guide += `- **Page:** Page-level components that represent routes\n`;
  guide += `- **Feature:** Components tied to specific application features\n`;
  guide += `- **Auth:** Authentication-related components\n`;
  guide += `- **Form:** Form components and controls\n`;
  guide += `- **Util:** Utility components for common functionality\n\n`;
  
  guide += `## Adding New Components\n\n`;
  guide += `When adding a new component:\n\n`;
  guide += `1. Check if a similar component already exists in the registry\n`;
  guide += `2. Follow the established naming conventions\n`;
  guide += `3. Add proper JSDoc documentation\n`;
  guide += `4. Update the component registry\n`;
  guide += `5. Use the appropriate folder structure based on the component type\n\n`;
  
  guide += `## Component Dependencies\n\n`;
  guide += `Keep component dependencies minimal to improve reusability. If a component requires many dependencies, consider breaking it down into smaller components.\n\n`;
  
  guide += `## Component Examples\n\n`;
  guide += `Here are examples of well-structured components in our application:\n\n`;
  
  // Add examples of well-structured components
  const exampleComponents = getAllComponents().filter(comp => 
    ['Layout', 'Header', 'ProtectedRoute'].includes(comp.name)
  );
  
  exampleComponents.forEach(comp => {
    guide += `### ${comp.name}\n\n`;
    guide += `Path: \`${comp.path}\`\n\n`;
    guide += `Purpose: ${comp.description}\n\n`;
    if (comp.example) {
      guide += `\`\`\`tsx\n${comp.example}\n\`\`\`\n\n`;
    }
  });
  
  return guide;
}; 